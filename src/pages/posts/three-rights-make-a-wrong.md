---
layout: ../../layouts/PostLayout.astro
title: 對、對、對，對了三次你就錯了
date: 2026-01-13T11:01
description: 每個選擇單獨看都對，合在一起就出包——軟體開發的組合拳陷阱
tags:
  - 觀念
---

最近踩了一個坑，細節寫在[另一篇](/posts/localstorage-base64-trap)。

簡單說就是：Base64 預覽圖片（對）+ useEffect 監聽狀態（對）+ localStorage 自動存檔（對）= 瀏覽器噴 `QuotaExceededError`（爆）。

讓我想了很久的不是怎麼修，而是**為什麼每一步都沒錯，結果卻是錯的**。

## 這叫組合拳陷阱

軟體開發裡到處都是這種情況。

每個決策單獨看都合理，但組合起來就出事。

### ORM + 迴圈查詢 + 流量

用 ORM 很方便，不用寫 raw SQL。

在迴圈裡查資料庫，邏輯清楚好讀。

系統上線，流量進來。

結果就是經典的 N+1 問題——一個列表頁打了 101 次資料庫。

```python
# 看起來很正常
for user in users:
    orders = Order.objects.filter(user_id=user.id)  # 每次都打一次 DB
```

單獨看每一行都沒問題。但 100 個 user 就是 100 次查詢。

### React 狀態提升 + 大量子元件 + 頻繁更新

狀態放在共同的祖先元件，React 官方推薦的做法。

拆成很多小元件，關注點分離，也是好習慣。

某個狀態需要頻繁更新（比如輸入框的值）。

結果整棵樹一直 re-render，頁面變得很卡。

因為狀態在最上面，改一次就是整棵樹重新算一遍。

### console.log + 到處加 + 忘記拿掉

除錯的時候加 `console.log`，很正常。

到處都加，因為不確定問題在哪。

修完 bug，趕著部署，忘記清掉。

正式環境的 console 噴一堆內部資料，有些還是敏感資訊。

### 微服務 + 同步呼叫 + 服務鏈過長

每個服務只做一件事，單一職責。

服務之間用 HTTP 溝通，標準做法。

業務邏輯需要串聯多個服務。

A 呼叫 B，B 呼叫 C，C 呼叫 D。任何一個慢了或掛了，整條鏈就斷了。

延遲疊加，錯誤放大。

## 為什麼會這樣

因為我們學東西的時候，都是**一個一個學**。

「Base64 怎麼用」「useEffect 怎麼用」「localStorage 怎麼用」。

但實際開發是**全部混在一起用**。

每個工具都有它的假設和限制：

| 工具 | 假設/限制 |
|------|-----------|
| Base64 | 資料會膨脹 33% |
| ORM | 每次 query 都有 overhead |
| 狀態提升 | 改一次全部 re-render |
| console.log | 會印到正式環境 |
| 同步呼叫 | 延遲會疊加 |

單獨用的時候，這些限制不明顯。

混在一起用，限制就會互相放大。

## 怎麼降低踩坑機率

沒辦法完全避免，但可以養成幾個習慣。

### 學工具的時候，順便記它的邊界

不只學「怎麼用」，也要知道「什麼時候不該用」。

localStorage 有 5MB 限制。ORM 查詢有 overhead。狀態提升會觸發整棵樹更新。

知道邊界，才知道什麼組合會撞牆。

### 寫完 code，在腦中跑一遍資料流

「這個資料有多大？會經過哪些地方？會被呼叫幾次？」

很多組合拳問題，在腦中模擬一遍就會發現。

### 測試的時候，專門測邊界情況

不要只測 happy path。

一張圖可以，十張呢？一個 user 可以，一百個呢？

邊界情況是組合拳最容易爆發的地方。

### 設計的時候，想一下「如果 X 變大會怎樣」

流量變大、資料變多、使用時間變長。

很多組合在小規模的時候完全沒問題，放大之後就爆了。

---

軟體開發沒有銀彈。

每個「Best Practice」都有它的適用範圍。

超出範圍，最佳實踐就變成最佳踩坑。
